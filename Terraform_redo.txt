-------------------------
Terraform
-----------------------

Инструмент для создания инфраструктуры как код.

---------
Установка
---------

https://learn.hashicorp.com/tutorials/terraform/install-cli

Установка происходит легко.


----------------
Плагины для Atom
----------------

Какие же нужны плагины под Atom:
- language-terraform;
- terraform-fmr;
- linter-terraform-syntacs

----------------------------------------------------------------------
Инициализация проекта.
Создание, удаление и изменение ресурса в AWS на примере EC2 instance'а
----------------------------------------------------------------------

---------------------
Инициализация проекта
---------------------

Перед тем как начинать создавать ресурсы, мы должны понять как работает terraform.
При запуске на выполнение, terraform ищет все файлы с суффиксом - tf в рабочей директории.
В связи с этим для каждого проекта, нужно создать отдельную директорию,
где будут храниться все tf файлы проекта.

$ mkdir ./001_Create_AWS_EC2_instance; cd ./001_Create_AWS_EC2_instance

В terraform для начала, нужно описать провайдера в котором мы будем создавать ресурс.
У нас в качестве провайдера будет выступать AWS.

Как же описывать провайдера? Да и вообще как найти документацию о том как что-то делать для определенного провайдера?
Легко, нужно найти его на официальном сайте (https://registry.terraform.io/browse/providers) и посмотреть документацию.
Вот ссылка на документацию - https://registry.terraform.io/providers/hashicorp/aws/latest/docs

Создадим tf файл с описанием провайдера. Название может быть произвольное.
Тут довольно таки все понятно. Стоит только отметить, что с помощью shared_credentials_files
мы указываем путь к файлу с настройками доступа к AWS.
Данный файл создается когда вы пользуетесь AWS CLI.

********************************************************************************
Отсупление:
https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html
По этой ссылке можно посмотреть как установить AWS CLI. После установки, нужно

$ aws configure

Далее, ввести актуальные ключи.

Вот подробней

https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html

********************************************************************************

$ touch ./aws_provider.tf

terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
    }
  }
}

provider "aws" {
  region = "eu-central-1"
  shared_credentials_files = ["~/.aws/credentials"]
  profile = "default"
}


Далее, инициализируем terraform проект

$ terraform init

Initializing the backend...

Initializing provider plugins...
- Finding latest version of hashicorp/aws...
- Installing hashicorp/aws v4.13.0...
- Installed hashicorp/aws v4.13.0 (signed by HashiCorp)

Terraform has created a lock file .terraform.lock.hcl to record the provider
selections it made above. Include this file in your version control repository
so that Terraform can guarantee to make the same selections by default when
you run "terraform init" in the future.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.

$ ls -la
total 20
drwxrwxr-x 3 denisb denisb 4096 мая  7 08:53 .
drwxrwxr-x 5 denisb denisb 4096 мая  7 08:44 ..
-rw-rw-r-- 1 denisb denisb  210 мая  7 08:47 aws_provider.tf
drwxr-xr-x 3 denisb denisb 4096 мая  7 08:53 .terraform
-rw-r--r-- 1 denisb denisb 1152 мая  7 08:53 .terraform.lock.hcl

-------------------------------------------
Указать учетные данные с помощью переменных
-------------------------------------------

Отдельно стоит отметить, что мы использовали ~/.aws/credentials в качестве учетных
данных. Хочу показать еще один расспространенный способ, который более предпочтительный,
т.к. над tf файлом могут работать разные люди у которых, например файл ~/.aws/credentials
может называться по-другому или вообще отсувствовать.

Еще одним способом указания учетных данных - является объявление некоторых переменных.
Ну и конечно создание для terraform отдельного пользователя в AWS с ограниченными правами.


$ export AWS_ACCESS_KEY_ID=<your access key id>
$ export AWS_SECRET_ACCESS_KEY=<your secret access key>
$ export AWS_DEFAULT_REGION=<your default region>

При этом файл с описанием провайдера, в нашем случае - aws_provider.tf, будет
иметь другой вид

terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
    }
  }
}

provider "aws" {}

----------------------------------------
Создание ресурса (EC2 Instance'а)
----------------------------------------

Вот все параметры как создавать данный ресурс
https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/instance

Создадим файл, в котором будем создавать ресурс. Название может быть произвольное.
Тут тоже должно быть все понятно

$ touch ./main.tf

resource "aws_instance" "my_amazon_linux" {
  ami = "ami-05f5f4f906feab6a7"
  instance_type = "t2.micro"

  key_name = "bochinskii_Frankfurt_2"

  vpc_security_group_ids = [
    "sg-004c28689f21a4a77",
    "sg-061ddb8453ccbf935"
  ]
  availability_zone = "eu-central-1a"
  subnet_id = "subnet-000c2008b7496a3b7"

  root_block_device {
    volume_type = "gp3"
    volume_size = 15
    delete_on_termination = true
  }

  tags = {
    Name = "my_amazon_linux"
    Owner = "Denis Bochinskii"
  }
}

Далее, проверим синтаксис и получим вывод, что terraform должен будет сделать.
На данном этапе можно все проверить и если вы ошиблись, то поправить определенные
tf файлы.

$ terraform plan

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

...

Plan: 1 to add, 0 to change, 0 to destroy.

Далее, выполняем tf файлы

$ terraform apply

...

Plan: 1 to add, 0 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

aws_instance.my_amazon_linux: Creating...
aws_instance.my_amazon_linux: Still creating... [10s elapsed]
aws_instance.my_amazon_linux: Still creating... [20s elapsed]
aws_instance.my_amazon_linux: Still creating... [30s elapsed]
aws_instance.my_amazon_linux: Still creating... [40s elapsed]
aws_instance.my_amazon_linux: Creation complete after 46s [id=i-0da179ee934358a97]

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.


Вот какой файл - terraform.tfstate появился после того, как мы выполнили команду - apply.

$ ls -l
total 16
-rw-rw-r-- 1 denisb denisb  210 мая  7 08:47 aws_provider.tf
-rw-rw-r-- 1 denisb denisb  426 мая  7 10:37 main.tf
-rw-rw-r-- 1 denisb denisb 4236 мая  7 10:41 terraform.tfstate

В нем находится вся информация о том, что сделано в данный момент в данном проекте.
Поэтому если мы запустим команду apply снова, terraform выдаст информацио о том,
что ничего создавать не нужно. Напомню, что эту информацию он берет из файла -
terraform.tfstate. Теперь можно сделать вывод, что файл terraform.tfstate очень важен.

$ terraform apply
aws_instance.my_amazon_linux: Refreshing state... [id=i-01168c67a974a129e]

No changes. Your infrastructure matches the configuration.

Terraform has compared your real infrastructure against your configuration and found no differences, so no changes are needed.

Apply complete! Resources: 0 added, 0 changed, 0 destroyed.


Давайте добавим еще одну кoнфигурацию ресурса в файл - main.tf. Создадим такой-же
ресурс, только в другой AZ

resource "aws_instance" "my_amazon_linux_2" {
  ami = "ami-05f5f4f906feab6a7"
  instance_type = "t2.micro"

  key_name = "bochinskii_Frankfurt_2"


  vpc_security_group_ids = [
    "sg-004c28689f21a4a77",
    "sg-061ddb8453ccbf935"
  ]
  availability_zone = "eu-central-1b"
  subnet_id = "subnet-0646580d441af171c"

  root_block_device {
    volume_type = "gp3"
    volume_size = 10
    delete_on_termination = true
  }

  tags = {
    Name = "my_amazon_linux"
    Owner = "Denis Bochinskii"
  }
}

$ terraform plan

Как мы видим, terrform знает, что ресурс my_amazon_linux уже создан,
а значит нужно создать только ресурс - my_amazon_linux_2. Таким образом у нас
запущены 2-а ec2 instance'а.

$ terraform apply

Plan: 1 to add, 0 to change, 0 to destroy.

...

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

aws_instance.my_amazon_linux_2: Creating...
aws_instance.my_amazon_linux_2: Still creating... [10s elapsed]
aws_instance.my_amazon_linux_2: Still creating... [20s elapsed]
aws_instance.my_amazon_linux_2: Still creating... [30s elapsed]
aws_instance.my_amazon_linux_2: Creation complete after 38s [id=i-046fcb00b46b64106]

*****************************************************************************************
Важно:
Если мы сейчас удалим файл - terraform.tfstate и запустим apply снова. то terraform
не будет знать о созданной им информатруктуре и начнет создавать эти два ресурса заново.
*****************************************************************************************


-----------------
Удаление ресурсов
-----------------


Один из вариантов - это удалить ненужный ресурс в tf файле. И запустить команду - apply.
Этот вариант хорошб, если вам нужно удалить определенный ресурс, который стал не нужен.

Удалим ресурс - my_amazon_linux_2 из main.tf файла

Теперь выполним команду plan.
Мы видим, что terrafom будет удалять ресурс my_amazon_linux_2

$ terraform plan
aws_instance.my_amazon_linux_2: Refreshing state... [id=i-046fcb00b46b64106]
aws_instance.my_amazon_linux: Refreshing state... [id=i-01168c67a974a129e]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  - destroy

Terraform will perform the following actions:

  # aws_instance.my_amazon_linux_2 will be destroyed
  # (because aws_instance.my_amazon_linux_2 is not in configuration)

  ...

Plan: 0 to add, 0 to change, 1 to destroy.

$ terraform apply

Ну, а что если не нужно изменять конфигурацию в tf файлах, но инфраструктуру нужно
удалить.

$ terraform destroy

Таким образом мы удалили все ресурсы описанные в tf файлах данного проекта (директории).

------------------
Изменение ресурсов
------------------

К этому времени уможе должно быть понятно, что изменять ресурсы можно изменяя код в
tf файлах, а потом выполнить команду - apply.





-----------------------------------------------
Зависимости и использование перемнных окружения
-----------------------------------------------

Создадим новый проект

$ mkdir ./002_Create_LEMP_file; cd ./002_Create_LEMP_file

Оставим "за кадром" создание конфигурации провайдера.

Экспортируем все необходимые переменные.

$ export AWS_ACCESS_KEY_ID=<your access key id>
$ export AWS_SECRET_ACCESS_KEY=<your secret access key>
$ export AWS_DEFAULT_REGION=<your default region>

Экспорт данной переменной, будет объяснен ниже.

$ export TF_VAR_ssh_port=<your custome ssh port number>

Просмотрим зависимости на примере создания LEMP сервера к которому будет "привязаны"
две новосозданные группы безопасности.

$ terraform init

$ touch main.tf

variable "ssh_port" {}

resource "aws_instance" "my_lemp" {
  ami = "ami-05f5f4f906feab6a7"
  instance_type = "t2.micro"

  key_name = "bochinskii_Frankfurt_2"

  vpc_security_group_ids = [
    aws_security_group.my_lemp_web.id,
    aws_security_group.my_lemp_ssh.id
  ]

  availability_zone = "eu-central-1a"
  subnet_id = "subnet-000c2008b7496a3b7"
  user_data_base64 = file("../secret/user_data.base64.sh")

  root_block_device {
    volume_type = "gp3"
    volume_size = 10
    delete_on_termination = true
  }

  tags = {
    Name = "my_lemp"
    Owner = "Denis Bochinskii"
  }
}

resource "aws_security_group" "my_lemp_web" {
  name        = "my_lemp_web"
  description = "Allow Web traffic"
  vpc_id      = "vpc-03ccdbfd7272a7584"

  ingress {
    description      = "To HTTP"
    from_port        = 80
    to_port          = 80
    protocol         = "tcp"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  ingress {
    description      = "To HTTPS"
    from_port        = 443
    to_port          = 443
    protocol         = "tcp"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  tags = {
    Name = "my_lemp_web"
    Owner = "Denis Bochinskii"
  }
}

resource "aws_security_group" "my_lemp_ssh" {
  name        = "my_lemp_ssh"
  description = "Allow Web traffic"
  vpc_id      = "vpc-03ccdbfd7272a7584"

  ingress {
    description      = "To SSH"
    from_port        = 22
    to_port          = 22
    protocol         = "tcp"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  ingress {
    description      = "To custome SSH"
    from_port        = var.ssh_port
    to_port          = var.ssh_port
    protocol         = "tcp"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  tags = {
    Name = "my_lemp_ssh"
    Owner = "Denis Bochinskii"
  }
}

В tf файле мы сперва укзали ресур aws_instance, а потом ресурсы aws_security_group.
Тем не менее мы создали автоматическую связь между aws_instance и aws_security_group
путем указания - aws_security_group.my_lemp_web.id и aws_security_group.my_lemp_ssh.id:

vpc_security_group_ids = [
  aws_security_group.my_lemp_web.id,
  aws_security_group.my_lemp_ssh.id
]

т.е. terraform просканировал tf файл и выяснил, что есть связь между ресурсами и таким образом
сначала создал группы безопасности, а потом уже ресурс с ec2 instance'ом.

********************************************
Заметка:

Рассмотрим как мы указали группы безопаности на примере одной - aws_security_group.my_lemp_web.id.
Эта запись состоит из названия ресурса (aws_security_group), его имени (my_lemp_web)
и одентификационного номера (id).

На самом деле можно "забрать" не только id, но и некоторые другие параметры.
Их можно найти в документации.

Если посмотреть на документацию по AWS - https://registry.terraform.io/providers/hashicorp/aws/latest/docs
то можно заметить, что документация о AWS сервисах, подразделяется на:
- resources
- data source
В resources описывается документация и параметры ресурса, а в data source
описывается то, что можно получить в качетсве переменной от созданного ресурса.

Вот data source документация например для группы безопасности -
https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/security_group
********************************************

https://www.terraform.io/language/values/variables

Далее, рассмотрим использование переменных окружения в tf файле.
Например, мы не захотели, чтобы в tf файле был показан
кастомный ssh порт. Как мы вышли из положения?

Как вы видели выше мы экспортровали вот такую переменную - TF_VAR_ssh_port,
в которой указали номер порта. Чтобы ее использовать в tf файле,
мы указали var.ssh_port в ресурсе группы безопасности.

Но этого мало. Еще нужно создать "мост" между tf файлом и вашим перемнным окружения.
Это делается с помощью объявления пустой переменной в tf файле:

variable "ssh_port" {}

https://www.terraform.io/language/functions/file

Ну и отметим, что мы использовали скрипт в base64 кодировке, для установки
LEMP. За это отвечает параметр - user_data_base64 в ресурсе - aws_instance.

Так же важным моментом является то, что если мы изменим user data скрипт и запустим
apply снова, что terraform поймет, что измнился скрипт и пересоздаст ec2 instance.

$ terraform init

$ terraform plan

$ terraform apply

Не забываем, что удалить ресурсы вот так

$ terraform destroy





--------------------------------------------------
Использование переменных и шаблонов (templatefile)
--------------------------------------------------

https://www.terraform.io/language/values/variables
https://www.terraform.io/language/functions/templatefile
https://www.terraform.io/language/functions/base64encode
https://www.terraform.io/language/functions/merge

Создадим новый проект:

$ mkdir 003_Create_LEMP_templatefile; cd 003_Create_LEMP_templatefile/

Экспортируем все необходимые переменные.

$ export AWS_ACCESS_KEY_ID=<your access key id>
$ export AWS_SECRET_ACCESS_KEY=<your secret access key>
$ export AWS_DEFAULT_REGION=<your default region>

$ export TF_VAR_ssh_port=<your custome ssh port number>
$ export TF_VAR_mysql_root_pass=<your mysql root password>
$ export TF_VAR_mysql_admin_user=<your mysql admin username>
$ export TF_VAR_mysql_admin_user_pass=<your mysql admin password>
$ export TF_VAR_mysql_drupal_user=<your mysql drupal username>
$ export TF_VAR_mysql_drupal_user_pass=<your mysql drupal user password>
$ export TF_VAR_mysql_drupal_db=<your mysql drupal database>
$ export TF_VAR_site_dir=<your prefix site directory>


$ terraform init

Опять же, изучать переменные и шаблоны будем на примере создания LEMP к которому
будут привязаны 2 ново созданные группы безопасности.

Для начала создадим отдельный файл с переменными. Это - best practice.

$ touch ./variables.tf

#
# Userd data variables
#
variable "hostname" {
  type = string
  default = "rocinante"
}
variable "timezone" {
  type = string
  default = "Europe/Berlin"
}
variable "ssh_port" {} # for user data and aws_security_group
variable "mysql_repo" {
  type = string
  default = "https://dev.mysql.com/get/mysql80-community-release-el7-6.noarch.rpm"
}
variable "mysql_root_pass" {}
variable "mysql_admin_user" {}
variable "mysql_admin_user_pass" {}
variable "mysql_drupal_user" {}
variable "mysql_drupal_user_pass" {}
variable "mysql_drupal_db" {}
variable "pkgs" {
  type = list(string)
  default = [
    "php", "php-fpm", "php-pdo", "php-mysqlnd", "php-xml", "php-gd", "php-curl",
    "php-mbstring", "php-json", "php-common", "php-gmp", "php-intl", "php-gd", "php-cli", "php-zip", "php-opcache"
  ]
}
variable "ssl_cert" {
  type = string
  default = "rocinante.crt"
}
variable "ssl_key" {
  type = string
  default = "rocinante.key"
}
variable "site_dir" {}
variable "site_config" {
  type = string
  default = "rocinante.conf"
}

# aws_instance variables

variable "ami" {
  type = string
  default = "ami-05f5f4f906feab6a7"
}

variable "instance_type" {
  type = string
  default = "t2.micro"
}

variable "key_name" {
  type = string
  default = "bochinskii_Frankfurt_2"
}

variable "availability_zone" {
  type = string
  default = "eu-central-1a"
}

variable "subnet_id" {
  type = string
  default = "subnet-000c2008b7496a3b7"
}

####### root_block_device variables

variable "volume_type" {
  type = string
  default = "gp3"
}

variable "volume_size" {
  type = number
  default = 10
}

# aws_security_group variables

variable "vpc_id" {
  type = string
  default = "vpc-03ccdbfd7272a7584"
}

# Other variables

variable "template_tags" {
  type = map
  default = {
    Owner = "Denis Bochinskii"
    Project = "rocinante"
    Env = "dev"
  }
}

У нас есть переменные, которые мы можем "показывать" в нашем проекте, а есть,
которые мы не хотим "показывать". Как бы там нибыло, мы должны определить все переменные.
Просто, те переменные, которые мы будем брать из переменных окружения мы определяем как пустые.

Стоит упомянуть, что переменные типа list (в нашем случае переменная имеет имя - pkgs)
и map (в нашем случае переменная имеет имя - template_tags) очень похожи.
Отличия в том, что list - это просто список, а map - имеет ключ и значение.

Переменные типа - string и number понятны без объяснения.

-------------------------------------------------------------------------------
Консолидируем по переменным:

Для того, чтобы использовать переменные окружения, их нужно определить, сделать
экспорт и использовать.

Например:

$ export TF_VAR_ssh_port=<port number>

$ nano variables.tf

variable "ssh_port" {}

$ nano main.tf

resource "aws_security_group" "my_lemp_ssh" {
  ...
  ingress {
    ...
    from_port        = var.ssh_port
    to_port          = var.ssh_port
    ...
  }
...
}


Для того, чтобы использовать переменные, их нужно определить и использовать.

Например:

$ nano variables.tf

variable "ami" {
  type = string
  default = "ami-05f5f4f906feab6a7"
}

$ nano main.tf

resource "aws_instance" "my_lemp" {
  ami = var.ami
  ...
}
-------------------------------------------------------------------------------

Создаем ft файл для ресурсов

$ touch ./main.tf

resource "aws_instance" "my_lemp" {
  ami = var.ami
  instance_type = var.instance_type

  key_name = var.key_name

  vpc_security_group_ids = [
    aws_security_group.my_lemp_web.id,
    aws_security_group.my_lemp_ssh.id
  ]

  availability_zone = var.availability_zone
  subnet_id = var.subnet_id
  # user_data = templatefile("./user_data.sh.tftpl", {})
  user_data_base64 = base64encode(templatefile("./user_data.sh.tftpl",
  {
    hostname = var.hostname,
    timezone = var.timezone,
    ssh_port = var.ssh_port,
    mysql_repo = var.mysql_repo,
    mysql_root_pass = var.mysql_root_pass,
    mysql_admin_user = var.mysql_admin_user,
    mysql_admin_user_pass = var.mysql_admin_user_pass,
    mysql_drupal_user = var.mysql_drupal_user,
    mysql_drupal_user_pass = var.mysql_drupal_user_pass,
    mysql_drupal_db = var.mysql_drupal_db,
    pkgs = var.pkgs,
    ssl_cert = var.ssl_cert,
    ssl_key = var.ssl_key,
    site_dir = var.site_dir,
    site_config = var.site_config
  }
  ))

  root_block_device {
    volume_type = var.volume_type
    volume_size = var.volume_size
    delete_on_termination = true
  }

  tags = merge(
    var.template_tags,
    {
      Name = "my_lemp_${var.template_tags["Env"]}"
    }
  )
  /*
  tags = {
    Name = "my_lemp"
    Owner = "Denis Bochinskii"
    Project = "rocinante"
    Env = "dev"
  }
  */
}

resource "aws_security_group" "my_lemp_web" {
  name        = "my_lemp_web"
  description = "Allow Web traffic"
  vpc_id      = var.vpc_id

  ingress {
    description      = "To HTTP"
    from_port        = 80
    to_port          = 80
    protocol         = "tcp"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  ingress {
    description      = "To HTTPS"
    from_port        = 443
    to_port          = 443
    protocol         = "tcp"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  tags = merge(
    var.template_tags,
    {
      Name = "my_lemp_web"
    }
  )

}

resource "aws_security_group" "my_lemp_ssh" {
  name        = "my_lemp_ssh"
  description = "Allow Web traffic"
  vpc_id      = var.vpc_id

  ingress {
    description      = "To SSH"
    from_port        = 22
    to_port          = 22
    protocol         = "tcp"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  ingress {
    description      = "To custome SSH"
    from_port        = var.ssh_port
    to_port          = var.ssh_port
    protocol         = "tcp"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  tags = merge(
    var.template_tags,
    {
      Name = "my_lemp_ssh"
    }
  )

}

Как мы уже говорили, обращаемся к переменным с помощью - var.<variable name>.

Тут стоит остановиться на конструкции:

tags = merge(
  var.template_tags,
  {
    Name = "my_lemp_${var.template_tags["Env"]}"
  }
)

Т.к. у нас есть теги одинаковый для всех ресурсов, то их удобно объявить в переменной
(в нашем случае с именем - template_tags), как мы и сделали. Но, у нас есть тэг отличающиеся
в зависимости от ресурсов (в нашем случае тэг - Name).

Для этого мы использовали функцию - merge. Она для объединения. Т.е. мы объединяем
два map. Одна объявлена с помощью переменной, а вторая map указана непосредственно
в функции.

Вот пример:

tags = merge(
  var.template_tags,
  {
    Name = "my_lemp_web"
  }
)

Так же примечательна конструкция:

Name = "my_lemp_${var.template_tags["Env"]}"

Тут мы указали имя (my_lemp_) + суффикс (${var.template_tags["Env"]}),
который берется из переменной template_tags, а именно из ключа - Env.


Теперь, по поводу шаблонов (templatefile).





Проверить файл шаблона, а именно, правильно ли он поставит переменные.

$ terraform console

templatefile("./user_data.sh.tftpl", {hostname = var.hostname, timezone = var.timezone, ssh_port = var.ssh_port, mysql_repo = var.mysql_repo, mysql_root_pass = var.mysql_root_pass, mysql_admin_user = var.mysql_admin_user, mysql_admin_user_pass = var.mysql_admin_user_pass, mysql_drupal_user = var.mysql_drupal_user, mysql_drupal_user_pass = var.mysql_drupal_user_pass, mysql_drupal_db = var.mysql_drupal_db, pkgs = var.pkgs, ssl_cert = var.ssl_cert, ssl_key = var.ssl_key, site_dir = var.site_dir, site_config = var.site_config})











-------------------------------------------------
